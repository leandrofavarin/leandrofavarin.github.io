<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>leandrofavarin.com</title>
   
   <link>http://leandrofavarin.com/</link>
   <description>Technology, creativity, photography, philosophy, music and whatever does not fit in 140 characters.</description>
   <language>en-us</language>
   <managingEditor> Leandro Favarin</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Exponential-Backoff RxJava operator with Jitter</title>
	  <link>//exponential-backoff-rxjava-operator-with-jitter</link>
	  <author>Leandro Favarin</author>
	  <pubDate>2017-03-11T11:30:00+01:00</pubDate>
	  <guid>//exponential-backoff-rxjava-operator-with-jitter</guid>
	  <description><![CDATA[
	     <p>After reading <a href="https://stripe.com/blog/idempotency">this article</a> about how Stripe handle errors between the clients and the server, I decided to write one in Java using RxJava 2.</p>

<noscript><pre>import java.util.concurrent.TimeUnit;

import io.reactivex.Observable;
import io.reactivex.annotations.NonNull;
import io.reactivex.functions.BiFunction;
import io.reactivex.functions.Function;

public class ExpBackoff implements Function&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;Long&gt;&gt; {
  private final Jitter jitter;
  private final long delay;
  private final TimeUnit units;
  private final int retries;

  /**
   * Exponential backoff that respects the equation: delay * retries ^ 2 * jitter
   *
   * @param retries The max number of retries or -1 to for MAX_INT times.
   */
  public ExpBackoff(Jitter jitter, long delay, TimeUnit units, int retries) {
    this.jitter = jitter;
    this.delay = delay;
    this.units = units;
    this.retries = retries &gt; 0 ? retries : Integer.MAX_VALUE;
  }

  @Override public Observable&lt;Long&gt; apply(
      @NonNull Observable&lt;? extends Throwable&gt; observable) throws Exception {
    return observable
        .zipWith(
            Observable.range(1, retries),
            (BiFunction&lt;Throwable, Integer, Integer&gt;) (throwable, retryCount) -&gt; retryCount)
        .flatMap((attemptNumber) -&gt; Observable.timer(getNewInterval(attemptNumber), units));
  }

  private long getNewInterval(int retryCount) {
    long newInterval = (long) (delay * Math.pow(retryCount, 2) * jitter.get());
    if (newInterval &lt; 0) {
      newInterval = Long.MAX_VALUE;
    }
    return newInterval;
  }
}

</pre></noscript>
<script src="https://gist.github.com/leandrofavarin/2ec45769c2383c371a63aab0e91099b0.js?file=ExpBackoff.java"> </script>

<p>With <code class="highlighter-rouge">Jitter</code> being:</p>

<noscript><pre>public interface Jitter {
  double get();

  Jitter NO_OP = () -&gt; 1;
}
</pre></noscript>
<script src="https://gist.github.com/leandrofavarin/2ec45769c2383c371a63aab0e91099b0.js?file=Jitter.java"> </script>

<p>A default implementation that could cause a 15% variance:</p>

<noscript><pre>import java.util.Random;

public class DefaultJitter implements Jitter {
  private final Random random = new Random();

  /** Returns a random value inside [0.85, 1.15] every time it&#39;s called */
  @Override public double get() {
    return 0.85 + random.nextDouble() % 0.3f;
  }
}
</pre></noscript>
<script src="https://gist.github.com/leandrofavarin/2ec45769c2383c371a63aab0e91099b0.js?file=DefaultJitter.java"> </script>

<p>The implementation here is not 1:1 to what Stripe did, but could be changed easily to adapt to your needs.</p>

<p>Its usage is simple. Just apply it before subscribing:</p>

<noscript><pre>``` java
observable
  ...
  .retryWhen(new ExpBackoff(new DefaultJitter(), delay: 1, TimeUnit.SECONDS, retries: 3))
  .subscribeWith(/* */);</pre></noscript>
<script src="https://gist.github.com/leandrofavarin/2ec45769c2383c371a63aab0e91099b0.js?file=USAGE.md"> </script>


	  ]]></description>
	</item>


</channel>
</rss>
